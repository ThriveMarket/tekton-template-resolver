name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Permissions needed for GitHub workflows
permissions:
  contents: read
  packages: write
  id-token: write # Needed for keyless signing
  actions: read

jobs:
  check-go-changes:
    name: Check for Go changes
    runs-on: ubuntu-latest
    outputs:
      go-changed: ${{ steps.filter.outputs.go }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for Go file changes
        uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            go:
              - '**/*.go'
              - 'go.mod'
              - 'go.sum'
              - '.golangci.yml'
              - 'vendor/**'
      
      - name: Show change status
        run: |
          echo "Go files changed: ${{ steps.filter.outputs.go }}"

  lint:
    name: Code Linting
    runs-on: ubuntu-latest
    needs: check-go-changes
    if: needs.check-go-changes.outputs.go-changed == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: true

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v7
        with:
          version: v2.0
          args: --timeout=5m ./cmd/...

  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: check-go-changes
    if: needs.check-go-changes.outputs.go-changed == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: true

      - name: Run tests
        run: go test ./... -v

      - name: Generate coverage report
        run: go test ./... -coverprofile=coverage.out

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage.out

  build:
    name: Build Container
    runs-on: ubuntu-latest
    needs: [check-go-changes, lint, test]
    if: always() # Run even if lint/test are skipped or failed
    steps:
      - uses: actions/checkout@v4

      # Skip the build if required steps failed (but not if they were skipped)
      - name: Check previous step results
        id: check
        run: |
          if [ "${{ contains(needs.*.result, 'failure') }}" = "true" ]; then
            echo "Previous steps failed, skipping build"
            exit 1
          fi
          
          # Check if we should build based on changes
          if [ "${{ needs.check-go-changes.outputs.go-changed }}" != "true" ]; then
            echo "No Go changes detected, using existing container image"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "Go changes detected, building new container image"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Set up Go
        if: steps.check.outputs.skip != 'true'
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: true

      - name: Install ko
        if: steps.check.outputs.skip != 'true'
        run: |
          curl -L https://github.com/google/ko/releases/download/v0.15.1/ko_0.15.1_Linux_x86_64.tar.gz | tar xzf - ko
          chmod +x ./ko
          sudo mv ko /usr/local/bin/

      - name: Set up Docker Buildx
        if: steps.check.outputs.skip != 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        if: steps.check.outputs.skip != 'true' && github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push container image
        if: steps.check.outputs.skip != 'true'
        id: docker_build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: |
            ghcr.io/thrivemarket/template-resolver:latest
            ghcr.io/thrivemarket/template-resolver:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  e2e-test:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    needs: [check-go-changes, build]
    if: always() && !contains(needs.*.result, 'failure')
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: true

      - name: Install Task
        run: |
          sh -c "$(curl --location https://taskfile.dev/install.sh)" -- -d -b /usr/local/bin

      - name: Install ko
        run: |
          curl -L https://github.com/google/ko/releases/download/v0.15.1/ko_0.15.1_Linux_x86_64.tar.gz | tar xzf - ko
          chmod +x ./ko
          sudo mv ko /usr/local/bin/

      - name: Create kind cluster
        uses: helm/kind-action@v1.12.0
        with:
          cluster_name: kind

      - name: Install Tekton Pipelines
        run: |
          # Install Tekton with proper error handling
          echo "Installing Tekton Pipelines..."
          kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml
          
          # Wait for Tekton to be ready with checks
          echo "Waiting for Tekton namespace..."
          kubectl wait --for=condition=established --timeout=60s crd/pipelineruns.tekton.dev || echo "Timed out waiting for CRD, but continuing..."
          
          echo "Waiting for Tekton controllers..."
          kubectl -n tekton-pipelines wait --for=condition=ready pod --selector=app.kubernetes.io/component=controller --timeout=180s || echo "Timed out waiting for controller, but continuing..."
          
          # Wait for webhook to avoid race conditions
          echo "Waiting for Tekton webhook..."
          kubectl -n tekton-pipelines wait --for=condition=ready pod --selector=app.kubernetes.io/component=webhook --timeout=180s || echo "Timed out waiting for webhook, but continuing..."

      - name: Build and deploy resolver
        run: |
          # Debug image references before starting
          echo "Debugging image references..."
          cat config/deployment.yaml
          
          # Always build locally for all CI runs (both PRs and pushes to main)
          # This ensures we don't need to pull from ghcr.io which requires auth
          echo "Building local image with ko"
          export KO_DOCKER_REPO=ko.local
          
          # Build the image
          IMAGE_REF=$(ko build --local -B thrivemarket.com/template-resolver/cmd/template-resolver)
          echo "Built image: $IMAGE_REF"
          
          # Load the image directly into kind
          echo "Loading image into kind cluster"
          kind load docker-image "$IMAGE_REF" --name=kind
          
          # Update the deployment file with the local image
          sed -i "s|image:.*|image: $IMAGE_REF|g" config/deployment.yaml
          
          # Show the updated deployment file
          echo "Updated deployment file:"
          cat config/deployment.yaml
          
          # Apply with namespace check
          kubectl create namespace tekton-pipelines-resolvers --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -f config/
          
          # Verify pod status
          echo "Checking pod status:"
          kubectl get pods -n tekton-pipelines-resolvers
          sleep 5
          kubectl get pods -n tekton-pipelines-resolvers

      - name: Make sure resolver pod is running
        run: |
          # Check if resolver pods are running correctly
          echo "Checking resolver pod status:"
          kubectl get pods -n tekton-pipelines-resolvers -l app=template-resolver -o wide
          
          # Debug any pod issues
          RESOLVER_POD=$(kubectl get pods -n tekton-pipelines-resolvers -l app=template-resolver -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
          if [ -n "$RESOLVER_POD" ]; then
            echo "Checking pod events:"
            kubectl describe pod -n tekton-pipelines-resolvers "$RESOLVER_POD"
            
            # Check if pod is failing to pull image
            CONTAINER_STATUS=$(kubectl get pod -n tekton-pipelines-resolvers "$RESOLVER_POD" -o jsonpath='{.status.containerStatuses[0].state.waiting.reason}' 2>/dev/null)
            if [ "$CONTAINER_STATUS" = "ImagePullBackOff" ] || [ "$CONTAINER_STATUS" = "ErrImagePull" ]; then
              echo "Image pull issue detected. Retrying with a local build..."
              
              # Rebuild with ko and try again
              export KO_DOCKER_REPO=ko.local
              IMAGE_REF=$(ko build --local -B thrivemarket.com/template-resolver/cmd/template-resolver)
              echo "Built image: $IMAGE_REF"
              
              # Load into kind and update deployment
              kind load docker-image "$IMAGE_REF" --name=kind
              kubectl set image deployment/template-resolver -n tekton-pipelines-resolvers controller="$IMAGE_REF"
              
              # Wait for pod to start
              echo "Waiting for resolver pod to become ready..."
              kubectl rollout status deployment/template-resolver -n tekton-pipelines-resolvers --timeout=2m
            fi
          else
            echo "No resolver pods found!"
          fi
          
          # Wait for all tekton system components to be ready
          echo "Waiting for all system components to be ready..."
          kubectl get pods -A
          
          # Make sure there's a longer timeout for resolution
          echo "Setting long resolution timeout..."
          kubectl patch deployment template-resolver -n tekton-pipelines-resolvers --type=json \
            -p='[{"op": "replace", "path": "/spec/template/spec/containers/0/env/6/value", "value": "10m"}]'
          
          # Wait for rollout to complete
          kubectl rollout status deployment/template-resolver -n tekton-pipelines-resolvers --timeout=2m

      - name: Validate template resolver with test-request
        run: |
          echo "Running basic template resolver validation with test-request.yaml..."
          
          # Delete any existing test request
          kubectl delete resolutionrequest test-request --ignore-not-found=true
          
          # Apply the test request
          kubectl apply -f test-request.yaml
          
          # Wait a bit for the resolution to happen (with error handling)
          echo "Waiting for resolution to complete..."
          for i in {1..30}; do
            STATUS=$(kubectl get resolutionrequest test-request -o jsonpath='{.status.conditions[0].status}' 2>/dev/null)
            if [ "$STATUS" = "True" ]; then
              echo "✓ Resolution succeeded!"
              break
            elif [ "$STATUS" = "False" ]; then
              echo "✗ Resolution failed."
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 2
          done
          
          # Check the resolution status
          REQUEST_STATUS=$(kubectl get resolutionrequest test-request -o yaml)
          echo "Resolution request status:"
          echo "$REQUEST_STATUS"
          
          # Check if data field exists
          DATA=$(kubectl get resolutionrequest test-request -o jsonpath='{.status.data}' 2>/dev/null)
          if [ -n "$DATA" ]; then
            echo "Rendered template data (first 20 lines):"
            echo "$DATA" | base64 -d | head -n 20
            
            # Verify the data contains template-y output
            TEMPLATE_OUTPUT=$(echo "$DATA" | base64 -d)
            if echo "$TEMPLATE_OUTPUT" | grep -q "apiVersion: tekton.dev/v1"; then
              echo "✓ Template output verified! Contains Tekton Pipeline definition."
            else
              echo "✗ Template output doesn't look correct."
              echo "Full output:"
              echo "$TEMPLATE_OUTPUT"
              exit 1
            fi
          else
            echo "❌ No data field found in the resolution request!"
            
            # Debug resolver logs
            RESOLVER_POD=$(kubectl get pods -n tekton-pipelines-resolvers -l app=template-resolver -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
            if [ -n "$RESOLVER_POD" ]; then
              echo "Resolver pod logs:"
              kubectl logs -n tekton-pipelines-resolvers "$RESOLVER_POD" --tail=100
            fi
            
            # Check resolution reason
            REASON=$(kubectl get resolutionrequest test-request -o jsonpath='{.status.conditions[0].reason}' 2>/dev/null)
            MESSAGE=$(kubectl get resolutionrequest test-request -o jsonpath='{.status.conditions[0].message}' 2>/dev/null)
            echo "Reason: $REASON"
            echo "Message: $MESSAGE"
            
            # If timeout, we should fail
            if [[ "$MESSAGE" == *"timeout"* ]]; then
              echo "❌ Resolution timed out!"
              exit 1
            fi
          fi

      - name: Run integration tests
        run: |
          # Run the e2e test and capture the exit code
          task test:e2e || {
            EXIT_CODE=$?
            
            # Dump the resolver logs regardless of failure reason
            echo "::group::Resolver Pod Logs (Last 100 lines)"
            echo "Tests failed with exit code $EXIT_CODE - Dumping resolver pod logs:"
            RESOLVER_POD=$(kubectl get pods -n tekton-pipelines-resolvers -l app=template-resolver -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
            if [ -n "$RESOLVER_POD" ]; then
              # Check pod status first
              echo "Pod status:"
              kubectl get pod -n tekton-pipelines-resolvers "$RESOLVER_POD" -o wide
              
              # Try to get logs
              echo "Pod logs:"
              kubectl logs -n tekton-pipelines-resolvers "$RESOLVER_POD" --tail=100 || echo "Failed to get logs"
              
              # Also check for timeout errors in the ResolutionRequest
              echo "::endgroup::"
              echo "::group::Resolution Request Status"
              PIPELINE_RUN_NAME="example-app-deployment"
              echo "Checking ResolutionRequest status for PipelineRun $PIPELINE_RUN_NAME..."
              LATEST_REQUEST=$(kubectl get resolutionrequest --sort-by=.metadata.creationTimestamp -o name 2>/dev/null | tail -n 1)
              if [ -n "$LATEST_REQUEST" ]; then
                REQUEST_NAME=${LATEST_REQUEST#*/}
                echo "Latest ResolutionRequest: $REQUEST_NAME"
                kubectl get resolutionrequest "$REQUEST_NAME" -o yaml
              else
                echo "No ResolutionRequest found"
              fi
            else
              echo "No resolver pod found in the tekton-pipelines-resolvers namespace"
              echo "All pods in the namespace:"
              kubectl get pods -n tekton-pipelines-resolvers
            fi
            echo "::endgroup::"
            
            # Preserve the original exit code
            exit $EXIT_CODE
          }
